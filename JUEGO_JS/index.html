<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop</title>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>

<script>
// Aquí estamos guardando una referencia al elemento <canvas> en la variable canvas.
// Después estamos creando la variable ctx para guardar el contexto de gráficos 2D,
// que es la herramienta  que realmente utilizaremos para dibujar.
var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");
var x = canvas.width/2;
var y = canvas.height-30;
var dx = 2;
var dy = -2;
var ballRadius = 10; // Para facilitar los cálculos, definamos una variable llamada ballRadius
var paddleHeight = 10;
var paddleWidth = 75;
var paddleX = (canvas.width-paddleWidth)/2;// que mantendrá el radio del círculo dibujado y se utilizará para los cálculos
var rightPressed = false;// boton que dira si se ha pulsaod la tecla derecha
var leftPressed = false;// boton que dira si se ha pulsaod la tecla izquierda
var brickRowCount = 3;
var brickColumnCount = 5;
var brickWidth = 75;
var brickHeight = 20;
var brickPadding = 10;
var brickOffsetTop = 30; //un margen superior (Top) e izquierdo (Left)
// para que no se dibujen tocando los bordes.
var brickOffsetLeft = 30;
// creara los bloques
// bricks[0][0] es el primer ladrillo (columna 0, fila 0) y se dibujará en "x" 0 e "y" 0.
// El siguiente ladrillo será el brick[0][1] (columna 0, fila 1) y se dibujará también en (0,0).
// Así, continuaremos hasta el final de la primera columna, que será el ladrillo bricks[0][2]
// porque hay 3 filas, de la 0 a la 2. Terminará así el bucle de dentro y seguirá el de fuera,
// valiendo ahora la "c" 1. Seguiremos recorriendo bricks[] hasta llegar a bricks[2][4],
// que es el último ladrillo. 
var bricks = [];
for(c=0; c<brickColumnCount; c++) {
    bricks[c] = [];
    for(r=0; r<brickRowCount; r++) {
        bricks[c][r] = { x: 0, y: 0 };
    }
}
// función para recorrer todos los bloques de la matriz y dibujarlos en la pantalla
// hemos añadido ctx.rect() para dibujar un rectángulo por cada ladrillo,
// además de otras llamadas a funciones para que, efectivamente, se dibuje el rectángulo.
// 
function drawBricks() {
    for(c=0; c<brickColumnCount; c++) {
        for(r=0; r<brickRowCount; r++) {
	    	// para no dibujar los ladrillos sobre si mismos
		// calculamos las posiciones x && y.
		//El primer ladrillo se dibujará arriba a la izquierda, concretamente en
		// (brickoffsetLeft, brickOffsetTop), porque c y r valen 0.
		//El siguiente ladrillo (columna 0, fila 1) se dibujará más abajo.
		var brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft;
		var brickY = (r*(brickHeight+brickPadding))+brickOffsetTop;
		bricks[c][r].x = 0;
        	bricks[c][r].y = 0;
        	ctx.beginPath();
        	ctx.rect(0, 0, brickWidth, brickHeight);
        	ctx.fillStyle = "#0095DD";
        	ctx.fill();
        	ctx.closePath();
        }
    }
}
// función que, con un bucle, recorrerá todos los ladrillos y comparará la posición 
//de cada uno con la posición de la bola, cada vez que se dibuje un fotograma.
// Para que el código sea más legible definiremos la variable "b" 
// que almacenará el objeto ladrillo en cada vuelta de bucle:
// NOTA Si el centro de la bola está dentro de las coordenadas de uno de nuestros ladrillos,
// cambiaremos la dirección de la bola. Se cumplirá que el centro de la bola
// está dentro de ladrillo si se cumplen al mismo tiempo estas cuatro condiciones:
// La posición "x" de la bola es mayor que la posición "x" del ladrillo
// La posición "x" de la bola es menor que la posición del ladrillo más el ancho del ladrillo
// La posición "y" de la bola es mayor que la posición "y" del ladrillo.
// sLa posición "y" de la bola es menor que la posición del ladrillo más su altura.
function collisionDetection() {
    for(c=0; c<brickColumnCount; c++) {
        for(r=0; r<brickRowCount; r++) {
            var b = bricks[c][r];
            if(x > b.x && x < b.x+brickWidth && y > b.y && y < b.y+brickHeight) {
                dy = -dy;
            }
        }
    }
}
// para no dibujar los ladrillos sobre si mismos
// calculamos las posiciones x && y.
//El primer ladrillo se dibujará arriba a la izquierda, concretamente en
// (brickoffsetLeft, brickOffsetTop), porque c y r valen 0.
//El siguiente ladrillo (columna 0, fila 1) se dibujará más abajo.
var brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft;
var brickY = (r*(brickHeight+brickPadding))+brickOffsetTop;
function drawBall() {
    ctx.beginPath();
    ctx.arc(x, y, ballRadius, 10, 0, Math.PI*2);
    ctx.fillStyle = "#F08080";
    ctx.fill();
    ctx.closePath();
}
// función que dibujará la paleta en la pantalla
function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight);
    ctx.fillStyle = "#0095DD";
    ctx.fill();
    ctx.closePath();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawPaddle(); // Dibuja la paleta dentro en la pantalla   
    drawBricks();   
    drawBall();
    x += dx;
    y += dy;
    if(x + dx > canvas.width || x + dx < ballRadius) {
    dx = -dx;
}
// game over del juego
// Si la bola toca el borde inferior del lienzo (Canvas) debemos comprobar si golpea la pala.
// Si es así, entonces rebota como el jugador se imagina que va a ocurrir;
// si no, el juego ha terminado.
if(y + dy < ballRadius) {
    dy = -dy;
} else if(y + dy > canvas.height-ballRadius) {
    if(x > paddleX && x < paddleX + paddleWidth) {
        dy = -dy;
    }
    else {
        alert("GAME OVER");
        document.location.reload();
    }
}
// La posición paddleX que estamos utilizando variará entre 0 para la lado izquierdo
// y canvas.width-paddleWidth para el lado derecho, que es justo lo que queremos.
if(rightPressed && paddleX < canvas.width-paddleWidth) {
    paddleX += 7;
}
else if(leftPressed && paddleX > 0) {
    paddleX -= 7;
}

}
document.addEventListener("keydown", keyDownHandler, false);
document.addEventListener("keyup", keyUpHandler, false);
// Cuando pulsamos una tecla se ejecuta keyDownHandler(e),
// que pone en la variable "e" los datos que necesitamos.
// Efectivamente, e.keyCode nos va a decir qué tecla se ha pulsado.
// Si vale 37 es porque se ha pulsado la "flecha izquierda" del teclado.
// El código 39 representa a la "flecha derecha".
function keyDownHandler(e) {
    if(e.keyCode == 39) {
        rightPressed = true;
    }
    else if(e.keyCode == 37) {
        leftPressed = true;
    }
}

function keyUpHandler(e) {
    if(e.keyCode == 39) {
        rightPressed = false;
    }
    else if(e.keyCode == 37) {
        leftPressed = false;
    }
}
setInterval(draw, 10);
</script>

</body>
</html>

/home/danibella/Desktop/JAVASCRIPT/JUEGO_JS